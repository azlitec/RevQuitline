generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                 String    @id @default(cuid())
  firstName          String?
  lastName           String?
  email              String    @unique
  password           String
  image              String?
  bio                String?
  dateOfBirth        DateTime?
  gender             String?
  phone              String?
  address            String?
  emergencyContact   String?
  emergencyPhone     String?
  medicalHistory     String?   @db.Text
  currentMedications String?   @db.Text
  allergies          String?   @db.Text
  smokingStatus      String?   @default("unknown")
  smokingHistory     String?   @db.Text
  quitAttempts       Int?      @default(0)
  quitDate           DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  role               String    @default("USER")
  isAdmin            Boolean   @default(false)
  isProvider         Boolean   @default(false)
  isClerk            Boolean   @default(false)
  licenseNumber      String?
  specialty          String?
  yearsOfExperience  Int?
  availability       Json?
  isOnline           Boolean   @default(false)
  lastSeen           DateTime?
  providerApprovalStatus ProviderApprovalStatus?
  
  // Relations
  appointmentsAsProvider Appointment[] @relation("ProviderAppointments")
  appointmentsAsPatient  Appointment[] @relation("PatientAppointments")
  healthRecordsAsProvider HealthRecord[] @relation("HealthRecordProvider")
  healthRecordsAsPatient HealthRecord[] @relation("HealthRecordPatient")
  vitalSigns VitalSign[] @relation("VitalSignPatient")
  smokingMetrics SmokingMetric[] @relation("SmokingMetricPatient")
  medicationsPrescribed Medication[] @relation("MedicationPrescribedBy")
  medicationsAsPatient Medication[] @relation("MedicationPatient")
  notifications Notification[] @relation("NotificationUser")
  doctorConnections DoctorPatientConnection[] @relation("DoctorConnections")
  patientConnections DoctorPatientConnection[] @relation("PatientConnections")
  patientInvoices Invoice[] @relation("PatientInvoices")
  providerInvoices Invoice[] @relation("ProviderInvoices")
  intakeForms IntakeForm[] @relation("IntakeFormPatient")
  conversationsAsProvider Conversation[] @relation("ConversationProvider")
  conversationsAsPatient Conversation[] @relation("ConversationPatient")
  sentMessages Message[] @relation("SentMessages")
}

// Service types enum
enum ServiceType {
  consultation
  follow_up
  emergency
  quitline_smoking_cessation
}

enum ProviderApprovalStatus {
  pending
  approved
  rejected
}

// Simple appointment model for now - we'll add more complex relations later
model Appointment {
  id          String      @id @default(cuid())
  title       String
  description String?     @db.Text
  date        DateTime
  duration    Int         @default(30) // minutes
  status      String      @default("scheduled") // scheduled, completed, cancelled, no-show
  type        ServiceType @default(consultation)
  serviceName String?     // Human readable service name
  price       Float?      // Service price in RM
  meetingLink String?
  notes       String?     @db.Text
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Simple relations for now
  providerId String
  provider   User   @relation("ProviderAppointments", fields: [providerId], references: [id], onDelete: Cascade, map: "Appointment_providerId_fkey")
  patientId  String
  patient    User   @relation("PatientAppointments", fields: [patientId], references: [id], onDelete: Cascade, map: "Appointment_patientId_fkey")
  invoice    Invoice? @relation("AppointmentInvoice")
}

// EHR Models for comprehensive patient data management
model HealthRecord {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  type        String   // progress_note, assessment, prescription, lab_result, therapy_note
  date        DateTime
  providerId  String
  provider    User     @relation("HealthRecordProvider", fields: [providerId], references: [id], onDelete: Cascade)
  patientId   String
  patient     User     @relation("HealthRecordPatient", fields: [patientId], references: [id], onDelete: Cascade)
  vitalSigns  Json?    // Store vital signs as JSON
  medications String?  @db.Text
  diagnosis   String?  @db.Text
  treatment   String?  @db.Text
  notes       String?  @db.Text
  attachments String[] // URLs to attached files
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([patientId])
  @@index([providerId])
  @@index([date])
}

model VitalSign {
  id          String   @id @default(cuid())
  patientId   String
  patient     User     @relation("VitalSignPatient", fields: [patientId], references: [id], onDelete: Cascade)
  recordedAt  DateTime
  bloodPressure String? // "120/80"
  heartRate    Int?
  oxygenSaturation Int? // percentage
  respiratoryRate Int?
  temperature  Float?   // in Fahrenheit
  weight       Float?   // in kg
  height       Float?   // in cm
  bmi          Float?
  createdAt    DateTime @default(now())

  @@index([patientId])
  @@index([recordedAt])
}

model SmokingMetric {
  id          String   @id @default(cuid())
  patientId   String
  patient     User     @relation("SmokingMetricPatient", fields: [patientId], references: [id], onDelete: Cascade)
  recordedAt  DateTime
  cigarettesPerDay Int?
  carbonMonoxideLevel Int? // ppm
  peakFlow    Int?    // L/min
  cravingsIntensity Int? // 1-10 scale
  quitDate    DateTime?
  quitDurationDays Int?
  createdAt   DateTime @default(now())

  @@index([patientId])
  @@index([recordedAt])
}

model Medication {
  id          String   @id @default(cuid())
  name        String
  dosage      String
  frequency   String
  startDate   DateTime
  endDate     DateTime?
  prescribedById String
  prescribedBy User   @relation("MedicationPrescribedBy", fields: [prescribedById], references: [id], onDelete: Cascade)
  patientId   String
  patient     User     @relation("MedicationPatient", fields: [patientId], references: [id], onDelete: Cascade)
  instructions String? @db.Text
  sideEffects String? @db.Text
  status      String   @default("active") // active, completed, discontinued
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([patientId])
  @@index([prescribedById])
  @@index([status])
}

model Notification {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation("NotificationUser", fields: [userId], references: [id], onDelete: Cascade)
  type        String   // alert, warning, info, success
  title       String
  message     String
  priority    String   // high, medium, low
  read        Boolean  @default(false)
  actionUrl   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([read])
  @@index([createdAt])
}

model DoctorPatientConnection {
  id            String   @id @default(cuid())
  providerId    String
  provider      User     @relation("DoctorConnections", fields: [providerId], references: [id], onDelete: Cascade)
  patientId     String
  patient       User     @relation("PatientConnections", fields: [patientId], references: [id], onDelete: Cascade)
  treatmentType String
  status        String   @default("pending") // pending, approved, rejected, disconnected
  requestMessage String? @db.Text
  approvedAt    DateTime?
  disconnectedAt DateTime?
  disconnectReason String?
  outstandingBalance Float @default(0)
  canDisconnect Boolean @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([providerId, patientId, treatmentType])
  @@index([providerId])
  @@index([patientId])
  @@index([status])
}

model Invoice {
  id            String   @id @default(cuid())
  invoiceNumber String   @unique
  patientId     String
  patient       User     @relation("PatientInvoices", fields: [patientId], references: [id], onDelete: Cascade)
  providerId    String?
  provider      User?    @relation("ProviderInvoices", fields: [providerId], references: [id])
  appointmentId String?  @unique
  appointment   Appointment? @relation("AppointmentInvoice", fields: [appointmentId], references: [id])
  description   String
  amount        Float
  status        String   @default("pending") // pending, paid, overdue, cancelled
  dueDate       DateTime
  paidAt        DateTime?
  paymentMethod String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([patientId])
  @@index([providerId])
  @@index([status])
  @@index([dueDate])
}

model IntakeForm {
  id            String   @id @default(cuid())
  appointmentId String   @unique
  patientId     String
  patient       User     @relation("IntakeFormPatient", fields: [patientId], references: [id], onDelete: Cascade)
  formData      Json     // Store the complete form data as JSON
  currentStep   Int      @default(1)
  completed     Boolean  @default(false)
  completedAt   DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([appointmentId])
  @@index([patientId])
  @@index([completed])
}

model Conversation {
  id          String   @id @default(cuid())
  providerId  String
  provider    User     @relation("ConversationProvider", fields: [providerId], references: [id], onDelete: Cascade)
  patientId   String
  patient     User     @relation("ConversationPatient", fields: [patientId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  messages    Message[]

  @@unique([providerId, patientId])
  @@index([providerId])
  @@index([patientId])
  @@index([updatedAt])
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  content        String   @db.Text
  read           Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
  @@index([read])
}
